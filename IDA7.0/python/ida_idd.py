# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: idd
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_idd', [dirname(__file__)])
        except ImportError:
            import _ida_idd
            return _ida_idd
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_idd', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_idd = swig_import_helper()
    del swig_import_helper
else:
    import _ida_idd
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        func.func_dict["bc695redef"] = True
        return func

class excvec_t(object):
    """
    Proxy of C++ qvector<(exception_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> excvec_t
        __init__(self, x) -> excvec_t
        """
        this = _ida_idd.new_excvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_excvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_idd.excvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_idd.excvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_idd.excvec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> exception_info_t
        """
        return _ida_idd.excvec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_idd.excvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.excvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.excvec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=exception_info_t())
        """
        return _ida_idd.excvec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_idd.excvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_idd.excvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_idd.excvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_idd.excvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_idd.excvec_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> exception_info_t
        begin(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> exception_info_t
        end(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> exception_info_t
        """
        return _ida_idd.excvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> exception_info_t
        erase(self, first, last) -> exception_info_t
        """
        return _ida_idd.excvec_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_idd.excvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> exception_info_t
        """
        return _ida_idd.excvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_idd.excvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

excvec_t_swigregister = _ida_idd.excvec_t_swigregister
excvec_t_swigregister(excvec_t)

class procinfo_vec_t(object):
    """
    Proxy of C++ qvector<(process_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> procinfo_vec_t
        __init__(self, x) -> procinfo_vec_t
        """
        this = _ida_idd.new_procinfo_vec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_procinfo_vec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_idd.procinfo_vec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_idd.procinfo_vec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_idd.procinfo_vec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.procinfo_vec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.procinfo_vec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=process_info_t())
        """
        return _ida_idd.procinfo_vec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_idd.procinfo_vec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_idd.procinfo_vec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_idd.procinfo_vec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_idd.procinfo_vec_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> process_info_t
        begin(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> process_info_t
        end(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> process_info_t
        erase(self, first, last) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_idd.procinfo_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

procinfo_vec_t_swigregister = _ida_idd.procinfo_vec_t_swigregister
procinfo_vec_t_swigregister(procinfo_vec_t)

IDD_INTERFACE_VERSION = _ida_idd.IDD_INTERFACE_VERSION
NO_THREAD = _ida_idd.NO_THREAD
class process_info_t(object):
    """
    Proxy of C++ process_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pid = _swig_property(_ida_idd.process_info_t_pid_get, _ida_idd.process_info_t_pid_set)
    name = _swig_property(_ida_idd.process_info_t_name_get, _ida_idd.process_info_t_name_set)
    def __init__(self, *args):
        """
        __init__(self) -> process_info_t
        """
        this = _ida_idd.new_process_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_process_info_t
    __del__ = lambda self : None;
process_info_t_swigregister = _ida_idd.process_info_t_swigregister
process_info_t_swigregister(process_info_t)

class debapp_attrs_t(object):
    """
    Proxy of C++ debapp_attrs_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cbsize = _swig_property(_ida_idd.debapp_attrs_t_cbsize_get, _ida_idd.debapp_attrs_t_cbsize_set)
    addrsize = _swig_property(_ida_idd.debapp_attrs_t_addrsize_get, _ida_idd.debapp_attrs_t_addrsize_set)
    platform = _swig_property(_ida_idd.debapp_attrs_t_platform_get, _ida_idd.debapp_attrs_t_platform_set)
    def __init__(self, *args):
        """
        __init__(self) -> debapp_attrs_t
        """
        this = _ida_idd.new_debapp_attrs_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_debapp_attrs_t
    __del__ = lambda self : None;
debapp_attrs_t_swigregister = _ida_idd.debapp_attrs_t_swigregister
debapp_attrs_t_swigregister(debapp_attrs_t)
DEF_ADDRSIZE = _ida_idd.DEF_ADDRSIZE

class scattered_segm_t(object):
    """
    Proxy of C++ scattered_segm_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_idd.scattered_segm_t_name_get, _ida_idd.scattered_segm_t_name_set)
    def __init__(self, *args):
        """
        __init__(self) -> scattered_segm_t
        """
        this = _ida_idd.new_scattered_segm_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_scattered_segm_t
    __del__ = lambda self : None;
scattered_segm_t_swigregister = _ida_idd.scattered_segm_t_swigregister
scattered_segm_t_swigregister(scattered_segm_t)

NO_EVENT = _ida_idd.NO_EVENT
PROCESS_START = _ida_idd.PROCESS_START
PROCESS_EXIT = _ida_idd.PROCESS_EXIT
THREAD_START = _ida_idd.THREAD_START
THREAD_EXIT = _ida_idd.THREAD_EXIT
BREAKPOINT = _ida_idd.BREAKPOINT
STEP = _ida_idd.STEP
EXCEPTION = _ida_idd.EXCEPTION
LIBRARY_LOAD = _ida_idd.LIBRARY_LOAD
LIBRARY_UNLOAD = _ida_idd.LIBRARY_UNLOAD
INFORMATION = _ida_idd.INFORMATION
SYSCALL = _ida_idd.SYSCALL
WINMESSAGE = _ida_idd.WINMESSAGE
PROCESS_ATTACH = _ida_idd.PROCESS_ATTACH
PROCESS_DETACH = _ida_idd.PROCESS_DETACH
PROCESS_SUSPEND = _ida_idd.PROCESS_SUSPEND
TRACE_FULL = _ida_idd.TRACE_FULL
class module_info_t(object):
    """
    Proxy of C++ module_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_idd.module_info_t_name_get, _ida_idd.module_info_t_name_set)
    base = _swig_property(_ida_idd.module_info_t_base_get, _ida_idd.module_info_t_base_set)
    size = _swig_property(_ida_idd.module_info_t_size_get, _ida_idd.module_info_t_size_set)
    rebase_to = _swig_property(_ida_idd.module_info_t_rebase_to_get, _ida_idd.module_info_t_rebase_to_set)
    def __init__(self, *args):
        """
        __init__(self) -> module_info_t
        """
        this = _ida_idd.new_module_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_module_info_t
    __del__ = lambda self : None;
module_info_t_swigregister = _ida_idd.module_info_t_swigregister
module_info_t_swigregister(module_info_t)

class e_breakpoint_t(object):
    """
    Proxy of C++ e_breakpoint_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    hea = _swig_property(_ida_idd.e_breakpoint_t_hea_get, _ida_idd.e_breakpoint_t_hea_set)
    kea = _swig_property(_ida_idd.e_breakpoint_t_kea_get, _ida_idd.e_breakpoint_t_kea_set)
    def __init__(self, *args):
        """
        __init__(self) -> e_breakpoint_t
        """
        this = _ida_idd.new_e_breakpoint_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_e_breakpoint_t
    __del__ = lambda self : None;
e_breakpoint_t_swigregister = _ida_idd.e_breakpoint_t_swigregister
e_breakpoint_t_swigregister(e_breakpoint_t)

class e_exception_t(object):
    """
    Proxy of C++ e_exception_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = _swig_property(_ida_idd.e_exception_t_code_get, _ida_idd.e_exception_t_code_set)
    can_cont = _swig_property(_ida_idd.e_exception_t_can_cont_get, _ida_idd.e_exception_t_can_cont_set)
    ea = _swig_property(_ida_idd.e_exception_t_ea_get, _ida_idd.e_exception_t_ea_set)
    info = _swig_property(_ida_idd.e_exception_t_info_get, _ida_idd.e_exception_t_info_set)
    def __init__(self, *args):
        """
        __init__(self) -> e_exception_t
        """
        this = _ida_idd.new_e_exception_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_e_exception_t
    __del__ = lambda self : None;
e_exception_t_swigregister = _ida_idd.e_exception_t_swigregister
e_exception_t_swigregister(e_exception_t)

class debug_event_t(object):
    """
    Proxy of C++ debug_event_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> debug_event_t
        """
        this = _ida_idd.new_debug_event_t(*args)
        try: self.this.append(this)
        except: self.this = this
    eid = _swig_property(_ida_idd.debug_event_t_eid_get, _ida_idd.debug_event_t_eid_set)
    pid = _swig_property(_ida_idd.debug_event_t_pid_get, _ida_idd.debug_event_t_pid_set)
    tid = _swig_property(_ida_idd.debug_event_t_tid_get, _ida_idd.debug_event_t_tid_set)
    ea = _swig_property(_ida_idd.debug_event_t_ea_get, _ida_idd.debug_event_t_ea_set)
    handled = _swig_property(_ida_idd.debug_event_t_handled_get, _ida_idd.debug_event_t_handled_set)
    modinfo = _swig_property(_ida_idd.debug_event_t_modinfo_get, _ida_idd.debug_event_t_modinfo_set)
    exit_code = _swig_property(_ida_idd.debug_event_t_exit_code_get, _ida_idd.debug_event_t_exit_code_set)
    info = _swig_property(_ida_idd.debug_event_t_info_get, _ida_idd.debug_event_t_info_set)
    bpt = _swig_property(_ida_idd.debug_event_t_bpt_get, _ida_idd.debug_event_t_bpt_set)
    exc = _swig_property(_ida_idd.debug_event_t_exc_get, _ida_idd.debug_event_t_exc_set)
    def bpt_ea(self, *args):
        """
        bpt_ea(self) -> ea_t
        """
        return _ida_idd.debug_event_t_bpt_ea(self, *args)

    __swig_destroy__ = _ida_idd.delete_debug_event_t
    __del__ = lambda self : None;
debug_event_t_swigregister = _ida_idd.debug_event_t_swigregister
debug_event_t_swigregister(debug_event_t)

class exception_info_t(object):
    """
    Proxy of C++ exception_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = _swig_property(_ida_idd.exception_info_t_code_get, _ida_idd.exception_info_t_code_set)
    flags = _swig_property(_ida_idd.exception_info_t_flags_get, _ida_idd.exception_info_t_flags_set)
    def break_on(self, *args):
        """
        break_on(self) -> bool
        """
        return _ida_idd.exception_info_t_break_on(self, *args)

    def handle(self, *args):
        """
        handle(self) -> bool
        """
        return _ida_idd.exception_info_t_handle(self, *args)

    name = _swig_property(_ida_idd.exception_info_t_name_get, _ida_idd.exception_info_t_name_set)
    desc = _swig_property(_ida_idd.exception_info_t_desc_get, _ida_idd.exception_info_t_desc_set)
    def __init__(self, *args):
        """
        __init__(self) -> exception_info_t
        __init__(self, _code, _flags, _name, _desc) -> exception_info_t
        """
        this = _ida_idd.new_exception_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_exception_info_t
    __del__ = lambda self : None;
exception_info_t_swigregister = _ida_idd.exception_info_t_swigregister
exception_info_t_swigregister(exception_info_t)
cvar = _ida_idd.cvar
BPT_WRITE = cvar.BPT_WRITE
BPT_READ = cvar.BPT_READ
BPT_RDWR = cvar.BPT_RDWR
BPT_SOFT = cvar.BPT_SOFT
BPT_EXEC = cvar.BPT_EXEC
BPT_DEFAULT = cvar.BPT_DEFAULT
EXC_BREAK = _ida_idd.EXC_BREAK
EXC_HANDLE = _ida_idd.EXC_HANDLE
EXC_MSG = _ida_idd.EXC_MSG
EXC_SILENT = _ida_idd.EXC_SILENT

class regval_t(object):
    """
    Proxy of C++ regval_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    rvtype = _swig_property(_ida_idd.regval_t_rvtype_get, _ida_idd.regval_t_rvtype_set)
    ival = _swig_property(_ida_idd.regval_t_ival_get, _ida_idd.regval_t_ival_set)
    fval = _swig_property(_ida_idd.regval_t_fval_get, _ida_idd.regval_t_fval_set)
    __swig_destroy__ = _ida_idd.delete_regval_t
    __del__ = lambda self : None;
    def __init__(self, *args):
        """
        __init__(self) -> regval_t
        __init__(self, r) -> regval_t
        """
        this = _ida_idd.new_regval_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.regval_t_clear(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_idd.regval_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_idd.regval_t___ne__(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_idd.regval_t_swap(self, *args)

    def _set_int(self, *args):
        """
        _set_int(self, x)
        """
        return _ida_idd.regval_t__set_int(self, *args)

    def _set_float(self, *args):
        """
        _set_float(self, x)
        """
        return _ida_idd.regval_t__set_float(self, *args)

    def _set_bytes(self, *args):
        """
        _set_bytes(self, data, size)
        _set_bytes(self, v)
        _set_bytes(self) -> bytevec_t &
        """
        return _ida_idd.regval_t__set_bytes(self, *args)

    def set_int(self, *args):
        """
        set_int(self, x)
        """
        return _ida_idd.regval_t_set_int(self, *args)

    def set_float(self, *args):
        """
        set_float(self, x)
        """
        return _ida_idd.regval_t_set_float(self, *args)

    def set_bytes(self, *args):
        """
        set_bytes(self, data, size)
        set_bytes(self, v)
        set_bytes(self) -> bytevec_t &
        """
        return _ida_idd.regval_t_set_bytes(self, *args)

    def bytes(self, *args):
        """
        bytes(self) -> bytevec_t
        bytes(self) -> bytevec_t const &
        """
        return _ida_idd.regval_t_bytes(self, *args)

    def get_data(self, *args):
        """
        get_data(self)
        get_data(self) -> void const *
        """
        return _ida_idd.regval_t_get_data(self, *args)

    def get_data_size(self, *args):
        """
        get_data_size(self) -> size_t
        """
        return _ida_idd.regval_t_get_data_size(self, *args)

regval_t_swigregister = _ida_idd.regval_t_swigregister
regval_t_swigregister(regval_t)
RVT_INT = _ida_idd.RVT_INT
RVT_FLOAT = _ida_idd.RVT_FLOAT

class call_stack_info_t(object):
    """
    Proxy of C++ call_stack_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    callea = _swig_property(_ida_idd.call_stack_info_t_callea_get, _ida_idd.call_stack_info_t_callea_set)
    funcea = _swig_property(_ida_idd.call_stack_info_t_funcea_get, _ida_idd.call_stack_info_t_funcea_set)
    fp = _swig_property(_ida_idd.call_stack_info_t_fp_get, _ida_idd.call_stack_info_t_fp_set)
    funcok = _swig_property(_ida_idd.call_stack_info_t_funcok_get, _ida_idd.call_stack_info_t_funcok_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_idd.call_stack_info_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_idd.call_stack_info_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> call_stack_info_t
        """
        this = _ida_idd.new_call_stack_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_call_stack_info_t
    __del__ = lambda self : None;
call_stack_info_t_swigregister = _ida_idd.call_stack_info_t_swigregister
call_stack_info_t_swigregister(call_stack_info_t)

class call_stack_t(object):
    """
    Proxy of C++ call_stack_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    dirty = _swig_property(_ida_idd.call_stack_t_dirty_get, _ida_idd.call_stack_t_dirty_set)
    def __init__(self, *args):
        """
        __init__(self) -> call_stack_t
        """
        this = _ida_idd.new_call_stack_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_call_stack_t
    __del__ = lambda self : None;
call_stack_t_swigregister = _ida_idd.call_stack_t_swigregister
call_stack_t_swigregister(call_stack_t)


def dbg_appcall(*args):
  """
  dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t
  """
  return _ida_idd.dbg_appcall(*args)

def cleanup_appcall(*args):
  """
  cleanup_appcall(tid) -> error_t
  """
  return _ida_idd.cleanup_appcall(*args)
RESMOD_NONE = _ida_idd.RESMOD_NONE
RESMOD_INTO = _ida_idd.RESMOD_INTO
RESMOD_OVER = _ida_idd.RESMOD_OVER
RESMOD_OUT = _ida_idd.RESMOD_OUT
RESMOD_SRCINTO = _ida_idd.RESMOD_SRCINTO
RESMOD_SRCOVER = _ida_idd.RESMOD_SRCOVER
RESMOD_SRCOUT = _ida_idd.RESMOD_SRCOUT
RESMOD_USER = _ida_idd.RESMOD_USER
RESMOD_HANDLE = _ida_idd.RESMOD_HANDLE
RESMOD_MAX = _ida_idd.RESMOD_MAX
RQ_MASKING = _ida_idd.RQ_MASKING
RQ_SUSPEND = _ida_idd.RQ_SUSPEND
RQ_NOSUSP = _ida_idd.RQ_NOSUSP
RQ_IGNWERR = _ida_idd.RQ_IGNWERR
RQ_SILENT = _ida_idd.RQ_SILENT
RQ_VERBOSE = _ida_idd.RQ_VERBOSE
RQ_SWSCREEN = _ida_idd.RQ_SWSCREEN
RQ__NOTHRRF = _ida_idd.RQ__NOTHRRF
RQ_PROCEXIT = _ida_idd.RQ_PROCEXIT
RQ_IDAIDLE = _ida_idd.RQ_IDAIDLE
RQ_SUSPRUN = _ida_idd.RQ_SUSPRUN
RQ_RESUME = _ida_idd.RQ_RESUME
RQ_RESMOD = _ida_idd.RQ_RESMOD
RQ_RESMOD_SHIFT = _ida_idd.RQ_RESMOD_SHIFT

def dbg_get_registers(*args):
  """
  dbg_get_registers() -> PyObject *


  This function returns the register definition from the currently loaded debugger.
  Basically, it returns an array of structure similar to to idd.hpp / register_info_t
  @return:
      None if no debugger is loaded
      tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
      The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)
  """
  return _ida_idd.dbg_get_registers(*args)

def dbg_get_thread_sreg_base(*args):
  """
  dbg_get_thread_sreg_base(py_tid, py_sreg_value) -> PyObject *


  Returns the segment register base value
  @param tid: thread id
  @param sreg_value: segment register (selector) value
  @return:
      - The base as an 'ea'
      - Or None on failure
  """
  return _ida_idd.dbg_get_thread_sreg_base(*args)

def dbg_read_memory(*args):
  """
  dbg_read_memory(py_ea, py_sz) -> PyObject *


  Reads from the debugee's memory at the specified ea
  @return:
      - The read buffer (as a string)
      - Or None on failure
  """
  return _ida_idd.dbg_read_memory(*args)

def dbg_write_memory(*args):
  """
  dbg_write_memory(py_ea, py_buf) -> PyObject *


  Writes a buffer to the debugee's memory
  @return: Boolean
  """
  return _ida_idd.dbg_write_memory(*args)

def dbg_get_name(*args):
  """
  dbg_get_name() -> PyObject *


  This function returns the current debugger's name.
  @return: Debugger name or None if no debugger is active
  """
  return _ida_idd.dbg_get_name(*args)

def dbg_get_memory_info(*args):
  """
  dbg_get_memory_info() -> PyObject *


  This function returns the memory configuration of a debugged process.
  @return:
      None if no debugger is active
      tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)
  """
  return _ida_idd.dbg_get_memory_info(*args)

def dbg_can_query(*args):
  """
  dbg_can_query() -> bool


  This function can be used to check if the debugger can be queried:
    - debugger is loaded
    - process is suspended
    - process is not suspended but can take requests. In this case some requests like
      memory read/write, bpt management succeed and register querying will fail.
      Check if idaapi.get_process_state() < 0 to tell if the process is suspended
  @return: Boolean
  """
  return _ida_idd.dbg_can_query(*args)

def appcall(*args):
  """
  appcall(func_ea, tid, py_type, py_fields, arg_list) -> PyObject *
  """
  return _ida_idd.appcall(*args)

def get_event_module_name(*args):
  """
  get_event_module_name(ev) -> char
  """
  return _ida_idd.get_event_module_name(*args)

def get_event_module_base(*args):
  """
  get_event_module_base(ev) -> ea_t
  """
  return _ida_idd.get_event_module_base(*args)

def get_event_module_size(*args):
  """
  get_event_module_size(ev) -> asize_t
  """
  return _ida_idd.get_event_module_size(*args)

def get_event_exc_info(*args):
  """
  get_event_exc_info(ev) -> char
  """
  return _ida_idd.get_event_exc_info(*args)

def get_event_info(*args):
  """
  get_event_info(ev) -> char
  """
  return _ida_idd.get_event_info(*args)

def get_event_bpt_hea(*args):
  """
  get_event_bpt_hea(ev) -> ea_t
  """
  return _ida_idd.get_event_bpt_hea(*args)

def get_event_exc_code(*args):
  """
  get_event_exc_code(ev) -> uint
  """
  return _ida_idd.get_event_exc_code(*args)

def get_event_exc_ea(*args):
  """
  get_event_exc_ea(ev) -> ea_t
  """
  return _ida_idd.get_event_exc_ea(*args)

def can_exc_continue(*args):
  """
  can_exc_continue(ev) -> bool
  """
  return _ida_idd.can_exc_continue(*args)
#<pycode(py_idd)>
NO_PROCESS = 0xFFFFFFFF
NO_THREAD  = 0

import types
import _ida_idaapi
import _ida_dbg
import _ida_typeinf
import _ida_name
import _ida_bytes
import _ida_ida
import ida_idaapi

# -----------------------------------------------------------------------
class Appcall_array__(object):
    """
    This class is used with Appcall.array() method
    """
    def __init__(self, tp):
        self.__type = tp

    def pack(self, L):
        """
        Packs a list or tuple into a byref buffer
        """
        t = type(L)
        if not (t == types.ListType or t == types.TupleType):
            raise ValueError, "Either a list or a tuple must be passed"
        self.__size = len(L)
        if self.__size == 1:
            self.__typedobj = Appcall__.typedobj(self.__type + ";")
        else:
            self.__typedobj = Appcall__.typedobj("%s x[%d];" % (self.__type, self.__size))
        # Now store the object in a string buffer
        ok, buf = self.__typedobj.store(L)
        if ok:
            return Appcall__.byref(buf)
        else:
            return None

    def try_to_convert_to_list(self, obj):
        """
        Is this object a list? We check for the existance of attribute zero and attribute self.size-1
        """
        if not (hasattr(obj, "0") and hasattr(obj, str(self.__size-1))):
            return obj
        # at this point, we are sure we have an "idc list"
        # let us convert to a Python list
        return [getattr(obj, str(x)) for x in xrange(0, self.__size)]

    def unpack(self, buf, as_list=True):
        """
        Unpacks an array back into a list or an object
        """
        # take the value from the special ref object
        if isinstance(buf, ida_idaapi.PyIdc_cvt_refclass__):
            buf = buf.value

        # we can only unpack from strings
        if type(buf) != types.StringType:
            raise ValueError, "Cannot unpack this type!"
        # now unpack
        ok, obj = self.__typedobj.retrieve(buf)
        if not ok:
            raise ValueError, "Failed while unpacking!"
        if not as_list:
            return obj
        return self.try_to_convert_to_list(obj)


# -----------------------------------------------------------------------
# Wrapper class for the appcall()
class Appcall_callable__(object):
    """
    Helper class to issue appcalls using a natural syntax:
      appcall.FunctionNameInTheDatabase(arguments, ....)
    or
      appcall["Function@8"](arguments, ...)
    or
      f8 = appcall["Function@8"]
      f8(arg1, arg2, ...)
    or
      o = appcall.obj()
      i = byref(5)
      appcall.funcname(arg1, i, "hello", o)
    """
    def __init__(self, ea, tp = None, fld = None):
        """
        Initializes an appcall with a given function ea
        """
        self.__ea     = ea
        self.__type   = tp
        self.__fields = fld
        self.__options = None # Appcall options
        self.__timeout = None # Appcall timeout

    def __get_timeout(self):
        return self.__timeout

    def __set_timeout(self, v):
        self.__timeout = v

    timeout = property(__get_timeout, __set_timeout)
    """
    An Appcall instance can change its timeout value with this attribute
    """

    def __get_options(self):
        return self.__options if self.__options != None else Appcall__.get_appcall_options()

    def __set_options(self, v):
        if self.timeout:
            # If timeout value is set, then put the timeout flag and encode the timeout value
            v |= Appcall__.APPCALL_TIMEOUT | (self.timeout << 16)
        else:
            # Timeout is not set, then clear the timeout flag
            v &= ~Appcall__.APPCALL_TIMEOUT

        self.__options = v

    options = property(__get_options, __set_options)
    """
    Sets the Appcall options locally to this Appcall instance
    """

    def __call__(self, *args):
        """
        Make object callable. We redirect execution to idaapi.appcall()
        """
        if self.ea is None:
            raise ValueError, "Object not callable!"

        # convert arguments to a list
        arg_list = list(args)

        # Save appcall options and set new global options
        old_opt = Appcall__.get_appcall_options()
        Appcall__.set_appcall_options(self.options)

        # Do the Appcall (use the wrapped version)
        e_obj = None
        try:
            r = _ida_idd.appcall(
               self.ea,
               _ida_dbg.get_current_thread(),
               self.type,
               self.fields,
               arg_list)
        except Exception as e:
            e_obj = e

        # Restore appcall options
        Appcall__.set_appcall_options(old_opt)

        # Return or re-raise exception
        if e_obj:
            raise Exception, e_obj

        return r

    def __get_ea(self):
        return self.__ea

    def __set_ea(self, val):
        self.__ea = val

    ea = property(__get_ea, __set_ea)
    """
    Returns or sets the EA associated with this object
    """

    def __get_size(self):
        if self.__type == None:
            return -1
        r = _ida_typeinf.calc_type_size(None, self.__type)
        if not r:
            return -1
        return r

    size = property(__get_size)
    """
    Returns the size of the type
    """

    def __get_type(self):
        return self.__type

    type = property(__get_type)
    """
    Returns the typestring
    """

    def __get_fields(self):
        return self.__fields

    fields = property(__get_fields)
    """
    Returns the field names
    """


    def retrieve(self, src=None, flags=0):
        """
        Unpacks a typed object from the database if an ea is given or from a string if a string was passed
        @param src: the address of the object or a string
        @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).
        """

        # Nothing passed? Take the address and unpack from the database
        if src is None:
            src = self.ea

        if type(src) == types.StringType:
            return _ida_typeinf.unpack_object_from_bv(None, self.type, self.fields, src, flags)
        else:
            return _ida_typeinf.unpack_object_from_idb(None, self.type, self.fields, src, flags)

    def store(self, obj, dest_ea=None, base_ea=0, flags=0):
        """
        Packs an object into a given ea if provided or into a string if no address was passed.
        @param obj: The object to pack
        @param dest_ea: If packing to idb this will be the store location
        @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers

        @return:
            - If packing to a string then a Tuple(Boolean, packed_string or error code)
            - If packing to the database then a return code is returned (0 is success)
        """

        # no ea passed? thus pack to a string
        if dest_ea is None:
            return _ida_typeinf.pack_object_to_bv(obj,
                                             None,
                                             self.type,
                                             self.fields,
                                             base_ea,
                                             flags)
        else:
            return _ida_typeinf.pack_object_to_idb(obj,
                                              None,
                                              self.type,
                                              self.fields,
                                              dest_ea,
                                              flags)

# -----------------------------------------------------------------------
class Appcall_consts__(object):
    """
    Helper class used by Appcall.Consts attribute
    It is used to retrieve constants via attribute access
"""
    def __init__(self, default=0):
        self.__default = default

    def __getattr__(self, attr):
        return Appcall__.valueof(attr, self.__default)

# -----------------------------------------------------------------------
class Appcall__(object):
    APPCALL_MANUAL = 0x1
    """
    Only set up the appcall, do not run it.
    you should call CleanupAppcall() when finished
    """

    APPCALL_DEBEV  = 0x2
    """
    Return debug event information
    If this bit is set, exceptions during appcall
    will generate idc exceptions with full
    information about the exception
    """

    APPCALL_TIMEOUT = 0x4
    """
    Appcall with timeout
    The timeout value in milliseconds is specified
    in the high 2 bytes of the 'options' argument:
    If timed out, errbuf will contain "timeout".
    """

    def __init__(self):
        self.__consts = Appcall_consts__()
    def __get_consts(self):
        return self.__consts
    Consts = property(__get_consts)
    """
    Use Appcall.Consts.CONST_NAME to access constants
    """

    @staticmethod
    def __name_or_ea(name_or_ea):
        """
        Function that accepts a name or an ea and checks if the address is enabled.
        If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
        @return:
            - Returns the resolved EA or
            - Raises an exception if the address is not enabled
        """

        # a string? try to resolve it
        if type(name_or_ea) == types.StringType:
            ea = _ida_name.get_name_ea(_ida_idaapi.BADADDR, name_or_ea)
        else:
            ea = name_or_ea
        # could not resolve name or invalid address?
        if ea == _ida_idaapi.BADADDR or not _ida_bytes.is_mapped(ea):
            raise ValueError, "Undefined function " + name_or_ea
        return ea

    @staticmethod
    def proto(name_or_ea, prototype, flags = None):
        """
        Allows you to instantiate an appcall (callable object) with the desired prototype
        @param name_or_ea: The name of the function (will be resolved with LocByName())
        @param prototype:
        @return:
            - On failure it raises an exception if the prototype could not be parsed
              or the address is not resolvable
            - Returns a callbable Appcall instance with the given prototypes and flags
        """

        # resolve and raise exception on error
        ea = Appcall__.__name_or_ea(name_or_ea)
        # parse the type
        if flags is None:
            flags = 1 | 2 | 4 # PT_SIL | PT_NDC | PT_TYP

        result = _ida_typeinf.idc_parse_decl(None, prototype, flags)
        if result is None:
            raise ValueError, "Could not parse type: " + prototype

        # Return the callable method with type info
        return Appcall_callable__(ea, result[1], result[2])

    def __getattr__(self, name_or_ea):
        """
        Allows you to call functions as if they were member functions (by returning a callable object)
        """
        # resolve and raise exception on error
        ea = self.__name_or_ea(name_or_ea)
        if ea == _ida_idaapi.BADADDR:
            raise ValueError, "Undefined function " + name
        # Return the callable method
        return Appcall_callable__(ea)

    def __getitem__(self, idx):
        """
        Use self[func_name] syntax if the function name contains invalid characters for an attribute name
        See __getattr___
        """
        return self.__getattr__(idx)

    @staticmethod
    def valueof(name, default=0):
        """
        Returns the numeric value of a given name string.
        If the name could not be resolved then the default value will be returned
        """
        t, v = _ida_name.get_name_value(_ida_idaapi.BADADDR, name)
        if t == 0: # NT_NONE
          v = default
        return v

    @staticmethod
    def int64(v):
        """
        Whenever a 64bit number is needed use this method to construct an object
        """
        return ida_idaapi.PyIdc_cvt_int64__(v)

    @staticmethod
    def byref(val):
        """
        Method to create references to immutable objects
        Currently we support references to int/strings
        Objects need not be passed by reference (this will be done automatically)
        """
        return ida_idaapi.PyIdc_cvt_refclass__(val)

    @staticmethod
    def buffer(str = None, size = 0, fill="\x00"):
        """
        Creates a string buffer. The returned value (r) will be a byref object.
        Use r.value to get the contents and r.size to get the buffer's size
        """
        if str is None:
            str = ""
        left = size - len(str)
        if left > 0:
            str = str + (fill * left)
        r = Appcall__.byref(str)
        r.size = size
        return r

    @staticmethod
    def obj(**kwds):
        """
        Returns an empty object or objects with attributes as passed via its keywords arguments
        """
        return ida_idaapi.object_t(**kwds)

    @staticmethod
    def cstr(val):
        return ida_idaapi.as_cstr(val)

    @staticmethod
    def unicode(s):
        return ida_idaapi.as_unicode(s)

    @staticmethod
    def array(type_name):
        """
        Defines an array type. Later you need to pack() / unpack()
        """
        return Appcall_array__(type_name)

    @staticmethod
    def typedobj(typestr, ea=None):
        """
        Parses a type string and returns an appcall object.
        One can then use retrieve() member method
        @param ea: Optional parameter that later can be used to retrieve the type
        @return: Appcall object or raises ValueError exception
        """
        # parse the type
        result = _ida_typeinf.idc_parse_decl(None, typestr, 1 | 2 | 4) # PT_SIL | PT_NDC | PT_TYP
        if result is None:
            raise ValueError, "Could not parse type: " + typestr
        # Return the callable method with type info
        return Appcall_callable__(ea, result[1], result[2])

    @staticmethod
    def set_appcall_options(opt):
        """
        Method to change the Appcall options globally (not per Appcall)
        """
        old_opt = Appcall__.get_appcall_options()
        _ida_ida.cvar.inf.appcall_options = opt
        return old_opt

    @staticmethod
    def get_appcall_options():
        """
        Return the global Appcall options
        """
        return _ida_ida.cvar.inf.appcall_options

    @staticmethod
    def cleanup_appcall(tid = 0):
        """
        Equivalent to IDC's CleanupAppcall()
        """
        return _ida_idd.cleanup_appcall(tid)

Appcall = Appcall__()
#</pycode(py_idd)>

if _BC695:
    PROCESS_NO_THREAD=NO_THREAD




